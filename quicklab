#!/bin/sh

#==================================================================================================
#title           :quicklab
#description     :quickly create/destroy multiple vms on vmware vcenter
#author          :Wesley van Tilburg
#license         :MIT
#date            :05/03/2023
#version         :0.1
#=================================================================================================

usage(){ printf "quicklab v0.1; 
USAGE
	quicklab  [args...]
ARGS
	-d enable debug logging
	-s the vcenter server
	-u username to login
	-i ignore certificate errors
	-m mode (create,destroy)
	-f the file containing the lab settings
	-h show this menu
";
exit 0
}

#=================Util functionomais=================

#Edit version of the log functions for aweb by job79
log() printf '\033[%sm%-0s \e[0m| %s\n' "${1:-33}" "$2" "$3" 

debug(){ if [ "$DEBUG" ]; then log "37" "DEBUG" "$1";fi }
info()  log "34" "INFO" "$1"
warn()  log "33" "WARNING" "$1" 
err() log "06;31" "ERROR" "$1"
errf(){ log "06;31" "ERROR" "$1"; exit 1; } #fatal error variant

#curl helper functions
request() eval "$CURL $1"
get() request "-X GET $1"
post() request "-X POST $1"
#===============================================

#Parse the placement field 
parse_placement(){
	info "Parsing placement fields and getting ids.."
	fields="cluster resource-pool datastore folder"
	for field in $fields 
	do
		#get the value from the yml
		yfield=".placement.$field"
		yvalue="$(yq -r "$yfield" $FILE)"

		#get the correct element for field $field and name $yvalue (name) if it does exists and is accessible by the user
		idjson="$(get "$SERVER/api/vcenter/$field" | jq --arg value "$yvalue" -r '.[] | select(.name==$value)')"

		#Fix the stupid naming difference: api url: resource-pool, response json: resource_pool
		if [ "$field" == "resource-pool" ]; then field="resource_pool"; fi 

		id="$(echo $idjson | jq --arg field "$field" -r '.[$field]')"
		if [ -z "$id" ]; then errf "Failed to get id for '$field' with the name '$yvalue' "; fi
		debug "$field : $id"

		#create a $field.json
		jq -n --arg field "$field" --arg id "$id" '{ "placement": { '$field': $id}}' >> "$TMP/$field".json
	done

	#create the placement json
	PLACEJSON="$(jq -n 'reduce inputs as $i ({}; . * $i)' "$TMP/"*.json >> "$TMP/placement.json")"
	debug "placement json: $(cat "$TMP/placement.json")"
}


#================= Create Logic =================
create(){
	#create a temp dir 
	TMP="$(mktemp -d)"

	#parse the placement field
	parse_placement
	
	#Get all networks that the user can access to limit calls
	networks="$(get "$SERVER/api/vcenter/network")"
	debug "networks: $networks"

	#get amount of vms
	vms="$(yq '.vms | length' "$FILE" 2>/dev/null)"
	if [ "$vms" -eq 0 ]; then errf "No vms found in '$FILE'"; fi
	index=0
	info "Parsing vms.."

	#parse all the vms
	while [ "$index" -lt "$vms" ]
	do
		debug "Parsing vm: $index"
		mkdir -p "$TMP/$index" && cp "$TMP/placement.json" "$TMP/$index"

		#handle the simple fields
		name="$(yq -r ".vms["$index"] .name" "$FILE")"
		os="$(yq -r ".vms["$index"] .guest_OS" "$FILE")"
		cores="$(yq -r ".vms["$index"] .cores" "$FILE")"
		if ! memory="$(units -o "%f" -t "$(yq -r ".vms[$index].memory" ./lab2.yaml)" "MB" | cut -d. -f1 2>/dev/null)"; then
			err "Failed to parse memory for vm '$name'"
			continue
		fi
		debug "memory $memory"

		#create the json for the simple parts
		jq -n --arg name "$name" --arg os "$os" --arg cores "$cores" --arg memory "$memory" '{"name":$name,"guest_OS":$os,"cpu":{"count":$cores},"memory":{"size_MiB":$memory}}' >> "$TMP/$index/simple.json"

		#create the final vm json
	        jq -n 'reduce inputs as $i ({}; . * $i)' "$TMP/$index/"*.json >> "$TMP/$index/vm.json"
		debug "VM json: $(cat $TMP/$index/vm.json)"

		#create the vm and save the id to a file
		resp="$(post "-H 'Content-Type: application/json' -d @$TMP/$index/vm.json $SERVER/api/vcenter/vm")"
		err="$(echo "$resp" | jq -r '.error_type' 2>/dev/null)"
		if [ -z "$err" ]; then
			info "Created vm '$name' with id $resp"
		else
			err "Failed to create vm '$name' due to the following reason '$resp'"
		fi
	

		index=$((index+1))
	done


}

#================= Dependency Logic =================
#Check if the requirements are installed
tools="curl jq yq"
for tool in $tools
do
	if ! command -v $tool >/dev/null; then err "Missing dependency: $tool";fi
done

#================= Argument Logic=================
#Default curl arguments
CURL="curl -s "

#handle input
while getopts 'du:m:f:is:h' OPTION 2>/dev/null; do
	case "$OPTION" in
		d) DEBUG=true;;
		f) FILE="$OPTARG";;
		h) usage; exit 0;;
		i) CURL="$CURL -k";;
		m) METHOD="$OPTARG";;
		s) SERVER="$OPTARG";;
		u) USER="$OPTARG";;
	esac
done

#check the required arguments
if [ -z "$FILE" ] || [ -z "$METHOD" ] || [ -z "$SERVER" ] || [ -z "$USER" ] ; then err "One of the required arguments is missing"; fi;


#validate method, this check serves as an early exit
if  [ "$METHOD" != "create" ] && [ "$METHOD" != "destroy" ]; then err "Method: '$METHOD' is not valid"; fi;

#Append https:// if not given
if ! echo "$SERVER" | grep -E -q "(http|https)://)"; then 
	SERVER="https://$SERVER"
fi

#make sure that the file exists
if ! [ -f "$FILE" ]; then err "File: '$FILE' does not exist."; fi

#Make sure we can access the server
if ! nc -zw2 "$(echo $SERVER | cut -d// -f3 )" 443 2>/dev/null; then err "Cannot reach server '$SERVER'"; fi;

#Read the password
info "Enter password (Will not echo)";stty -echo;read PASS; stty echo
info "Trying to login.."

#Login to the server
session="$(post "$SERVER/api/session -u $USER:$PASS" | jq -r )"
if ! [ -z "$( echo $session | grep error)" ]; then errf "Failed to login"; fi
info "Login successful"
CURL="$CURL -H 'vmware-api-session-id: $session'"

#Execute correct logic
case $METHOD in
	create) create;;
esac




